// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince', []).constant('cfg', {
    title: 'The Prince',
    cellCount: 6
  }).controller('MainController', function($scope, gameBoard, Piece, PieceDefinitions) {
    $scope.definitions = PieceDefinitions;
    $scope.newPiece = $scope.definitions.bowman;
    $scope.gameBoard = gameBoard;
    $scope.addPiece = function(ptype, pteam, px, py) {
      return gameBoard.pieces.push(new Piece({
        type: ptype,
        x: px,
        y: py,
        team: pteam
      }));
    };
    gameBoard.pieces.push(new Piece({
      type: PieceDefinitions.TYPES.prince,
      x: 3,
      y: 5,
      team: 0
    }));
    gameBoard.pieces.push(new Piece({
      type: PieceDefinitions.TYPES.footman,
      x: 2,
      y: 5,
      team: 0
    }));
    gameBoard.pieces.push(new Piece({
      type: PieceDefinitions.TYPES.prince,
      x: 3,
      y: 0,
      team: 1
    }));
    return gameBoard.pieces.push(new Piece({
      type: PieceDefinitions.TYPES.footman,
      x: 2,
      y: 0,
      team: 1
    }));
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince').factory('PieceDefinitions', function() {
    var ACTIONS, TYPES, definitions;
    TYPES = {
      prince: 'prince',
      footman: 'footman',
      pikeman: 'pikeman',
      bowman: 'bowman',
      champion: 'champion',
      dragoon: 'dragoon',
      assassin: 'assassin',
      general: 'general',
      knight: 'knight',
      marshall: 'marshall',
      priest: 'priest',
      seer: 'seer',
      wizard: 'wizard',
      longbowman: 'longbowman',
      oracle: 'oracle',
      duchess: 'duchess'
    };
    ACTIONS = {
      move: 'move',
      slide: 'slide',
      jump: 'jump',
      jumpslide: 'jumpslide',
      strike: 'strike',
      command: 'command'
    };
    definitions = {
      TYPES: TYPES,
      ACTIONS: ACTIONS,
      prince: {
        type: TYPES.prince,
        actions: [
          {
            slide: [[-1, 0], [1, 0]]
          }, {
            slide: [[0, -1], [0, 1]]
          }
        ]
      },
      footman: {
        type: TYPES.footman,
        actions: [
          {
            move: [[0, -1], [-1, 0], [1, 0], [0, 1]]
          }, {
            move: [[0, -2], [-1, -1], [1, -1], [-1, 1], [1, 1]]
          }
        ]
      },
      pikeman: {
        type: TYPES.pikeman,
        actions: [
          {
            move: [[-2, -2], [2, -2], [-1, -1], [1, -1]]
          }, {
            strike: [[-1, -2], [1, -2]],
            move: [[0, -1], [0, 1], [0, 2]]
          }
        ]
      },
      bowman: {
        type: TYPES.bowman,
        actions: [
          {
            jump: [[-2, 0], [2, 0], [0, 2]],
            move: [[0, -1], [-1, 0], [1, 0]]
          }, {
            strike: [[0, -2], [-1, -1], [1, -1]],
            move: [[0, -1], [-1, 1], [1, 1]]
          }
        ]
      },
      champion: {
        type: TYPES.champion,
        actions: [
          {
            jump: [[0, -2], [-2, 0], [2, 0], [0, 2]],
            move: [[0, -1], [-1, 0], [1, 0], [0, 1]]
          }, {
            jump: [[0, -2], [-2, 0], [2, 0], [0, 2]],
            strike: [[0, -1], [-1, 0], [1, 0], [0, 1]]
          }
        ]
      },
      dragoon: {
        type: TYPES.dragoon,
        actions: [
          {
            strike: [[-2, -2], [0, -2], [2, -2]],
            move: [[-1, 0], [1, 0]]
          }, {
            jump: [[-1, -2], [1, -2]],
            slide: [[-1, 1], [1, 1]],
            move: [[0, -2], [0, -1]]
          }
        ]
      },
      assassin: {
        type: TYPES.assassin,
        actions: [
          {
            jumpslide: [[0, -2], [-2, 2], [2, 2]]
          }, {
            jumpslide: [[-2, -2], [2, -2], [0, 2]]
          }
        ]
      },
      general: {
        type: TYPES.general,
        actions: [
          {
            jump: [[-1, -2], [1, -2]],
            move: [[0, -1], [-2, 0], [2, 0], [0, 1]]
          }, {
            jump: [[-1, -2], [1, -2]],
            move: [[0, -1], [-2, 0], [-1, 0], [1, 0], [2, 0]],
            command: [[-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]
          }
        ]
      },
      knight: {
        type: TYPES.knight,
        actions: [
          {
            jump: [[-1, -2], [1, -2]],
            move: [[-1, 0], [1, 0], [0, 1], [0, 2]]
          }, {
            slide: [[0, -1]],
            move: [[-1, 1], [1, 1], [-2, 2], [2, 2]]
          }
        ]
      },
      marshall: {
        type: TYPES.marshall,
        actions: [
          {
            jump: [[-2, -2], [2, -2], [0, 2]],
            slide: [[-1, 0], [1, 0]]
          }, {
            move: [[-1, -1], [0, -1], [1, -1], [-2, 0], [-1, 0], [1, 0], [2, 0], [-1, 1], [1, 1]],
            command: [[-1, -1], [0, -1], [1, -1]]
          }
        ]
      },
      priest: {
        type: TYPES.priest,
        actions: [
          {
            slide: [[-1, -1], [1, -1], [-1, 1], [1, 1]]
          }, {
            jump: [[-2, -2], [2, -2], [-2, 2], [2, 2]],
            move: [[-1, -1], [1, -1], [-1, 1], [1, 1]]
          }
        ]
      },
      seer: {
        type: TYPES.seer,
        actions: [
          {
            jump: [[0, -2], [-2, 0], [2, 0], [0, 2]],
            move: [[-1, -1], [1, -1], [-1, 1], [1, 1]]
          }, {
            jump: [[-2, -2], [2, -2], [-2, 2], [2, 2]],
            move: [[0, -1], [-1, 0], [1, 0], [0, 1]]
          }
        ]
      },
      wizard: {
        type: TYPES.wizard,
        actions: [
          {
            move: [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]
          }, {
            jump: [[-2, -2], [0, -2], [2, -2], [-2, 0], [2, 0], [-2, 2], [0, 2], [2, 2]]
          }
        ]
      },
      longbowman: {
        type: TYPES.longbowman,
        actions: [
          {
            move: [[-1, 0], [0, -1], [1, 0], [0, 1]]
          }, {
            move: [[-1, 1], [1, 1]],
            strike: [[0, -2], [0, -3]]
          }
        ]
      },
      oracle: {
        type: TYPES.oracle,
        actions: [
          {
            move: [[-1, -1], [1, -1], [-1, 1], [1, 1]]
          }
        ]
      },
      duchess: {
        type: TYPES.duchess,
        actions: [
          {
            move: [[-1, 0], [1, 0], [0, 2]],
            command: [[-2, 0], [-1, 0], [1, 0], [2, 0]]
          }, {
            move: [[-1, 0], [1, 0], [0, 2]],
            command: [[-2, 0], [-1, 0], [1, 0], [2, 0]]
          }
        ]
      }
    };
    return definitions;
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince').factory('Space', function() {
    var Space;
    Space = function(location) {
      this.x = location.x;
      return this.y = location.y;
    };
    Space.prototype = {
      x: void 0,
      y: void 0,
      highlight: ""
    };
    return Space;
  }).factory('gameBoard', function(cfg, Space, PieceDefinitions) {
    var gameBoard, space, x, y, _i, _j, _ref, _ref1;
    gameBoard = {
      locations: [],
      spaces: [],
      pieces: [],
      selectedPiece: null
    };
    for (x = _i = 0, _ref = cfg.cellCount; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      gameBoard.locations[x] = [];
      for (y = _j = 0, _ref1 = cfg.cellCount; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        space = new Space({
          x: x,
          y: y
        });
        gameBoard.spaces.push(space);
        gameBoard.locations[x].push(space);
      }
    }
    gameBoard.clearHighlights = function() {
      var p, _k, _l, _len, _len1, _ref2, _ref3, _results;
      _ref2 = gameBoard.spaces;
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        space = _ref2[_k];
        space.highlight = "";
      }
      _ref3 = gameBoard.pieces;
      _results = [];
      for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
        p = _ref3[_l];
        _results.push(p.attacked = "");
      }
      return _results;
    };
    gameBoard.showActions = function(piece) {
      var actions, coords, loc, offset, p, type, _results;
      if (gameBoard.selectedPiece && piece.team !== gameBoard.selectedPiece.team) {
        return;
      }
      if (!piece) {
        return;
      }
      gameBoard.clearHighlights();
      actions = piece.getActions();
      console.log('highlight actions: ', actions, piece.team);
      _results = [];
      for (type in actions) {
        coords = actions[type];
        if (type === PieceDefinitions.ACTIONS.move || type === PieceDefinitions.ACTIONS.jump || type === PieceDefinitions.ACTIONS.strike) {
          _results.push((function() {
            var _k, _l, _len, _len1, _ref2, _ref3, _results1;
            _results1 = [];
            for (_k = 0, _len = coords.length; _k < _len; _k++) {
              offset = coords[_k];
              x = piece.x + offset[0];
              y = piece.y + offset[1] * piece.getTeamOrientation();
              loc = (_ref2 = gameBoard.locations[x]) != null ? _ref2[y] : void 0;
              if (loc) {
                loc.highlight = type;
                _ref3 = gameBoard.pieces;
                for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
                  p = _ref3[_l];
                  if (p.x === loc.x && p.y === loc.y) {
                    if (p.team === piece.team) {
                      loc.highlight = "";
                    } else {
                      p.attacked = type;
                    }
                  }
                }
                _results1.push(console.log("loc", loc));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        } else {
          _results.push(console.warn("coord display rules for type " + type + " not yet implemented"));
        }
      }
      return _results;
    };
    gameBoard.getSpace = function(x, y) {
      var _ref2;
      return (_ref2 = gameBoard.locations[x]) != null ? _ref2[y] : void 0;
    };
    gameBoard.unselectCurrent = function() {
      if (gameBoard.selectedPiece) {
        gameBoard.selectedPiece.selected = false;
      }
      gameBoard.selectedPiece = null;
      return gameBoard.clearHighlights();
    };
    gameBoard.selectPiece = function(piece) {
      console.log("gb.select ", piece);
      if (piece.attacked !== "") {
        gameBoard.selectedPiece.act(gameBoard.getSpace(piece.x, piece.y));
        gameBoard.removePiece(piece);
        gameBoard.selectedPiece.showActions();
        return;
      }
      if (gameBoard.selectedPiece) {
        gameBoard.selectedPiece.selected = false;
      }
      gameBoard.selectedPiece = piece;
      gameBoard.selectedPiece.selected = true;
      return gameBoard.selectedPiece.showActions();
    };
    gameBoard.clickSpace = function(space) {
      console.log("click space", space);
      if (gameBoard.selectedPiece) {
        if (space.highlight !== "") {
          gameBoard.selectedPiece.act(space);
          return;
        }
        return gameBoard.unselectCurrent();
      }
    };
    gameBoard.movePiece = function(piece, pos) {
      var p, _k, _len, _ref2, _ref3;
      space = gameBoard.getSpace(pos.x, pos.y);
      if (space && ((_ref2 = space.highlight) === PieceDefinitions.ACTIONS.move || _ref2 === PieceDefinitions.ACTIONS.jump)) {
        piece.act(space);
      }
      _ref3 = gameBoard.pieces;
      for (_k = 0, _len = _ref3.length; _k < _len; _k++) {
        p = _ref3[_k];
        if (p.x === pos.x && p.y === pos.y && p.attacked) {
          console.log("attack", p.x, p.y, p.definition);
          gameBoard.removePiece(p);
          return;
        }
      }
    };
    gameBoard.removePiece = function(piece) {
      var index;
      index = gameBoard.pieces.indexOf(piece);
      if (index !== -1) {
        gameBoard.pieces.splice(index, 1);
        return gameBoard.clearHighlights();
      }
    };
    return gameBoard;
  }).directive('gameBoard', function(gameBoard, $window, cfg) {
    return {
      restrict: 'E',
      scope: {},
      template: '<b\n  ng-repeat="space in board.spaces"\n  class="space x{{space.x}} y{{space.y}} highlight{{space.highlight}}"\n  ng-class="{altColor: (space.x + space.y) % 2 === 0}"\n  ng-click="board.clickSpace(space)"\n  title="{{space.x}}, {{space.y}}">\n</b>\n\n<i piece\n   ng-repeat="piece in board.pieces"\n   ng-click="piece.selectPiece()"\n   ng-mouseover="piece.showActions()"\n   ng-mouseleave="board.selectedPiece.showActions()"\n   class="piece {{piece.type}} x{{piece.x}} y{{piece.y}} team{{piece.team}} select{{piece.selected}} attacked{{piece.attacked}} side{{piece.getSide()}}">\n  {{piece.type}}\n</i>',
      link: function(scope, el, attrs) {
        var calculateSize;
        scope.board = gameBoard;
        calculateSize = function() {
          var size;
          if ($window.innerWidth > $window.innerHeight) {
            size = window.innerHeight;
          } else {
            size = window.innerWidth;
          }
          size = Math.floor(size);
          size -= 40;
          el.css({
            width: size,
            height: size
          });
          cfg.boardSize = size;
          return cfg.pieceSize = Math.round(size / cfg.cellCount);
        };
        $window.onresize = _.debounce(calculateSize, 200);
        return calculateSize();
      }
    };
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince').factory('Piece', function(cfg, gameBoard, PieceDefinitions) {
    var Piece;
    Piece = function(options) {
      var definition;
      definition = PieceDefinitions[options.type];
      if (!definition) {
        console.warn("No Piece Definition found for type: " + options.type);
      }
      angular.extend(this, definition);
      this.x = options.x;
      this.y = options.y;
      return this.team = options.team;
    };
    Piece.prototype = {
      x: void 0,
      y: void 0,
      team: void 0,
      attacked: false,
      actionCount: 0,
      selected: false,
      getSide: function() {
        if (this.actionCount % 2 === 0) {
          return 0;
        } else {
          return 1;
        }
      },
      getActions: function() {
        return this.actions[this.getSide()];
      },
      getTeamOrientation: function() {
        if (this.team === 1) {
          return -1;
        } else {
          return 1;
        }
      },
      showActions: function() {
        return gameBoard.showActions(this);
      },
      selectPiece: function() {
        console.log("selected: ", this);
        return gameBoard.selectPiece(this);
      },
      movePiece: function(pos) {
        return gameBoard.movePiece(this, pos);
      },
      act: function(pos) {
        var highlight;
        highlight = pos.highlight;
        gameBoard.clearHighlights();
        if (pos.x < 0) {
          return 'off the left';
        }
        if (pos.x > cfg.cellCount - 1) {
          return 'off the right';
        }
        if (pos.y < 0) {
          return 'off the top';
        }
        if (pos.y > cfg.cellCount - 1) {
          return 'off the bottom';
        }
        if (!((pos.x != null) && (pos.y != null))) {
          return 'missing a position';
        }
        if (pos.x === this.x && pos.y === this.y) {
          return 'already in this position';
        }
        this.actionCount++;
        if (highlight === PieceDefinitions.ACTIONS.move || highlight === PieceDefinitions.ACTIONS.jump) {
          this.x = pos.x;
          return this.y = pos.y;
        }
      }
    };
    return Piece;
  }).directive('piece', function(cfg) {
    return {
      restrict: 'A',
      link: function(scope, el, attrs) {
        var draggie, setPosition;
        draggie = new Draggabilly(el[0]);
        draggie.on('dragEnd', function(draggie, evt, pointer) {
          var col, pos, row;
          if (!cfg.pieceSize) {
            console.warn('can not position piece without knowing size');
          }
          col = Math.round(draggie.position.x / cfg.pieceSize);
          row = Math.round(draggie.position.y / cfg.pieceSize);
          pos = {
            x: col,
            y: row
          };
          return setPosition(pos);
        });
        return setPosition = function(pos) {
          draggie.element.style.left = null;
          return draggie.element.style.top = null;
        };
      }
    };
  });

}).call(this);
