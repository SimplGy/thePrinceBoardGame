// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince', []).constant('cfg', {
    title: 'The Prince',
    cellCount: 6
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince').factory('Space', function() {
    var Space;
    Space = function(location) {
      this.x = location.x;
      return this.y = location.y;
    };
    Space.prototype = {
      x: void 0,
      y: void 0
    };
    return Space;
  }).factory('gameBoard', function(cfg, Space, Piece) {
    var api, space, x, y, _i, _j, _ref, _ref1;
    api = {
      locations: [],
      spaces: [],
      pieces: []
    };
    for (y = _i = 0, _ref = cfg.cellCount; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
      api.locations[y] = [];
      for (x = _j = 0, _ref1 = cfg.cellCount; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        space = new Space({
          x: x,
          y: y
        });
        api.spaces.push(space);
        api.locations[y].push;
      }
    }
    api.pieces.push(new Piece({
      type: Piece.TYPES.prince,
      x: 2,
      y: 5
    }));
    api.pieces.push(new Piece({
      type: Piece.TYPES.footman,
      x: 2,
      y: 4
    }));
    api.pieces.push(new Piece({
      type: Piece.TYPES.footman,
      x: 3,
      y: 5
    }));
    return api;
  }).directive('gameBoard', function(gameBoard, $window, cfg) {
    return {
      restrict: 'E',
      scope: {},
      template: '<b\n  ng-repeat="space in board.spaces"\n  class="space x{{space.x}} y{{space.y}}"\n  ng-class="{altColor: (space.x + space.y) % 2 === 0}" title="{{space.x}}, {{space.y}}">\n</b>\n\n<i piece\n   ng-repeat="piece in board.pieces"\n   class="piece {{piece.type}} x{{piece.x}} y{{piece.y}} team{{piece.team}} side{{piece.getSide()}}">\n  {{piece.type}} [{{piece.getSide()}}]\n</i>',
      link: function(scope, el, attrs) {
        var calculateSize;
        scope.board = gameBoard;
        calculateSize = function() {
          var size;
          if ($window.innerWidth > $window.innerHeight) {
            size = window.innerHeight;
          } else {
            size = window.innerWidth;
          }
          size = Math.floor(size);
          size -= 40;
          el.css({
            width: size,
            height: size
          });
          cfg.boardSize = size;
          return cfg.pieceSize = Math.round(size / cfg.cellCount);
        };
        $window.onresize = _.debounce(calculateSize, 200);
        return calculateSize();
      }
    };
  });

}).call(this);

// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('prince').factory('Piece', function() {
    var Piece, _static;
    _static = {
      TYPES: {
        prince: 'prince',
        footman: 'footman'
      }
    };
    Piece = function(options) {
      this.type = options.type;
      this.x = options.x;
      return this.y = options.y;
    };
    Piece.prototype = {
      x: void 0,
      y: void 0,
      actions: 0,
      getSide: function() {
        if (this.actions % 2 === 0) {
          return 0;
        } else {
          return 1;
        }
      },
      move: function(pos) {
        if (pos.x === this.x && pos.y === this.y) {
          return null;
        } else {
          this.x = pos.x;
          this.y = pos.y;
          return this.actions++;
        }
      },
      team: 0
    };
    return angular.extend(Piece, _static);
  }).directive('piece', function(cfg) {
    return {
      restrict: 'A',
      link: function(scope, el, attrs) {
        var draggie, pieceSize, setPosition;
        console.log('piece scope', scope);
        pieceSize = void 0;
        draggie = new Draggabilly(el[0]);
        draggie.on('dragEnd', function(draggie, evt, pointer) {
          var col, pos, row;
          if (!cfg.pieceSize) {
            console.warn('can not position piece without knowing size');
          }
          col = Math.round(draggie.position.x / cfg.pieceSize);
          if ((0 < col && col > cfg.cellCount)) {
            col = null;
          }
          row = Math.round(draggie.position.y / cfg.pieceSize);
          if ((0 < row && row > cfg.cellCount)) {
            row = null;
          }
          pos = {
            x: col,
            y: row
          };
          return setPosition(pos);
        });
        return setPosition = function(pos) {
          draggie.element.style.left = null;
          draggie.element.style.top = null;
          if (!((pos.x != null) && (pos.y != null))) {
            return;
          }
          return scope.$apply(function() {
            return scope.piece.move(pos);
          });
        };
      }
    };
  });

}).call(this);
